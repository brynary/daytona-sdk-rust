/*
 * Daytona
 *
 * Daytona AI platform API Docs
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@daytona.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`click_mouse_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClickMouseDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_folder_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFolderDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_pty_session_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreatePtySessionDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_session_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSessionDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_file_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFileDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_pty_session_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeletePtySessionDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_session_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSessionDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`download_file_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DownloadFileDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`download_files_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DownloadFilesDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`drag_mouse_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DragMouseDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`execute_command_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExecuteCommandDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`execute_session_command_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExecuteSessionCommandDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`find_in_files_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FindInFilesDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_computer_use_status_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetComputerUseStatusDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_display_info_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDisplayInfoDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_file_info_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFileInfoDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_mouse_position_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMousePositionDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_process_errors_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetProcessErrorsDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_process_logs_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetProcessLogsDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_process_status_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetProcessStatusDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_project_dir_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetProjectDirDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_pty_session_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPtySessionDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_session_command_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSessionCommandDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_session_command_logs_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSessionCommandLogsDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_session_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSessionDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_home_dir_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserHomeDirDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_windows_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWindowsDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_work_dir_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWorkDirDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`git_add_files_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GitAddFilesDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`git_checkout_branch_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GitCheckoutBranchDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`git_clone_repository_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GitCloneRepositoryDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`git_commit_changes_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GitCommitChangesDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`git_create_branch_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GitCreateBranchDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`git_delete_branch_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GitDeleteBranchDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`git_get_history_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GitGetHistoryDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`git_get_status_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GitGetStatusDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`git_list_branches_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GitListBranchesDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`git_pull_changes_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GitPullChangesDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`git_push_changes_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GitPushChangesDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_files_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFilesDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_pty_sessions_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListPtySessionsDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_sessions_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSessionsDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lsp_completions_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LspCompletionsDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lsp_did_close_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LspDidCloseDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lsp_did_open_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LspDidOpenDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lsp_document_symbols_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LspDocumentSymbolsDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lsp_start_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LspStartDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lsp_stop_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LspStopDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lsp_workspace_symbols_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LspWorkspaceSymbolsDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`move_file_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MoveFileDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`move_mouse_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MoveMouseDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`press_hotkey_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PressHotkeyDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`press_key_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PressKeyDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`replace_in_files_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReplaceInFilesDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`resize_pty_session_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResizePtySessionDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`restart_process_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestartProcessDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`scroll_mouse_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScrollMouseDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_files_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchFilesDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_file_permissions_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetFilePermissionsDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_computer_use_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartComputerUseDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stop_computer_use_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StopComputerUseDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`take_compressed_region_screenshot_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TakeCompressedRegionScreenshotDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`take_compressed_screenshot_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TakeCompressedScreenshotDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`take_region_screenshot_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TakeRegionScreenshotDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`take_screenshot_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TakeScreenshotDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`type_text_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TypeTextDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`upload_file_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UploadFileDeprecatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`upload_files_deprecated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UploadFilesDeprecatedError {
    UnknownValue(serde_json::Value),
}


/// Click mouse at specified coordinates
pub async fn click_mouse_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, mouse_click_request: models::MouseClickRequest, x_daytona_organization_id: Option<&str>) -> Result<models::MouseClickResponse, Error<ClickMouseDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_mouse_click_request = mouse_click_request;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/computeruse/mouse/click", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_mouse_click_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MouseClickResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MouseClickResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ClickMouseDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create folder inside sandbox
pub async fn create_folder_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, path: &str, mode: &str, x_daytona_organization_id: Option<&str>) -> Result<(), Error<CreateFolderDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_path = path;
    let p_mode = mode;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/files/folder", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("path", &p_path.to_string())]);
    req_builder = req_builder.query(&[("mode", &p_mode.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateFolderDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new PTY session in the sandbox
pub async fn create_pty_session_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, pty_create_request: models::PtyCreateRequest, x_daytona_organization_id: Option<&str>) -> Result<models::PtyCreateResponse, Error<CreatePtySessionDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_pty_create_request = pty_create_request;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/process/pty", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_pty_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PtyCreateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PtyCreateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreatePtySessionDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new session in the sandbox
pub async fn create_session_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, create_session_request: models::CreateSessionRequest, x_daytona_organization_id: Option<&str>) -> Result<(), Error<CreateSessionDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_create_session_request = create_session_request;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/process/session", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_create_session_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSessionDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete file inside sandbox
pub async fn delete_file_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, path: &str, x_daytona_organization_id: Option<&str>, recursive: Option<bool>) -> Result<(), Error<DeleteFileDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_path = path;
    let p_x_daytona_organization_id = x_daytona_organization_id;
    let p_recursive = recursive;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/files", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_recursive {
        req_builder = req_builder.query(&[("recursive", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("path", &p_path.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteFileDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a PTY session and terminate the associated process
pub async fn delete_pty_session_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, session_id: &str, x_daytona_organization_id: Option<&str>) -> Result<(), Error<DeletePtySessionDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_session_id = session_id;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/process/pty/{sessionId}", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id), sessionId=crate::apis::urlencode(p_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeletePtySessionDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a specific session
pub async fn delete_session_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, session_id: &str, x_daytona_organization_id: Option<&str>) -> Result<(), Error<DeleteSessionDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_session_id = session_id;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/process/session/{sessionId}", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id), sessionId=crate::apis::urlencode(p_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteSessionDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Download file from sandbox
pub async fn download_file_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, path: &str, x_daytona_organization_id: Option<&str>) -> Result<reqwest::Response, Error<DownloadFileDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_path = path;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/files/download", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("path", &p_path.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<DownloadFileDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Streams back a multipart/form-data bundle of the requested paths
pub async fn download_files_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, download_files: models::DownloadFiles, x_daytona_organization_id: Option<&str>) -> Result<reqwest::Response, Error<DownloadFilesDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_download_files = download_files;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/files/bulk-download", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_download_files);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<DownloadFilesDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Drag mouse from start to end coordinates
pub async fn drag_mouse_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, mouse_drag_request: models::MouseDragRequest, x_daytona_organization_id: Option<&str>) -> Result<models::MouseDragResponse, Error<DragMouseDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_mouse_drag_request = mouse_drag_request;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/computeruse/mouse/drag", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_mouse_drag_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MouseDragResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MouseDragResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DragMouseDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Execute command synchronously inside sandbox
pub async fn execute_command_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, execute_request: models::ExecuteRequest, x_daytona_organization_id: Option<&str>) -> Result<models::ExecuteResponse, Error<ExecuteCommandDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_execute_request = execute_request;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/process/execute", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_execute_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ExecuteResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ExecuteResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ExecuteCommandDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Execute a command in a specific session
pub async fn execute_session_command_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, session_id: &str, session_execute_request: models::SessionExecuteRequest, x_daytona_organization_id: Option<&str>) -> Result<models::SessionExecuteResponse, Error<ExecuteSessionCommandDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_session_id = session_id;
    let p_session_execute_request = session_execute_request;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/process/session/{sessionId}/exec", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id), sessionId=crate::apis::urlencode(p_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_session_execute_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SessionExecuteResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SessionExecuteResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ExecuteSessionCommandDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search for text/pattern inside sandbox files
pub async fn find_in_files_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, path: &str, pattern: &str, x_daytona_organization_id: Option<&str>) -> Result<Vec<models::Match>, Error<FindInFilesDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_path = path;
    let p_pattern = pattern;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/files/find", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("path", &p_path.to_string())]);
    req_builder = req_builder.query(&[("pattern", &p_pattern.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Match&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Match&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FindInFilesDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get status of all VNC desktop processes
pub async fn get_computer_use_status_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, x_daytona_organization_id: Option<&str>) -> Result<models::ComputerUseStatusResponse, Error<GetComputerUseStatusDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/computeruse/status", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ComputerUseStatusResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ComputerUseStatusResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetComputerUseStatusDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get information about displays
pub async fn get_display_info_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, x_daytona_organization_id: Option<&str>) -> Result<models::DisplayInfoResponse, Error<GetDisplayInfoDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/computeruse/display/info", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DisplayInfoResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DisplayInfoResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDisplayInfoDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get file info inside sandbox
pub async fn get_file_info_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, path: &str, x_daytona_organization_id: Option<&str>) -> Result<models::FileInfo, Error<GetFileInfoDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_path = path;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/files/info", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("path", &p_path.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FileInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FileInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFileInfoDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get current mouse cursor position
pub async fn get_mouse_position_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, x_daytona_organization_id: Option<&str>) -> Result<models::MousePosition, Error<GetMousePositionDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/computeruse/mouse/position", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MousePosition`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MousePosition`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMousePositionDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get error logs for a specific VNC process
pub async fn get_process_errors_deprecated(configuration: &configuration::Configuration, process_name: &str, sandbox_id: &str, x_daytona_organization_id: Option<&str>) -> Result<models::ProcessErrorsResponse, Error<GetProcessErrorsDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_process_name = process_name;
    let p_sandbox_id = sandbox_id;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/computeruse/process/{processName}/errors", configuration.base_path, processName=crate::apis::urlencode(p_process_name), sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProcessErrorsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProcessErrorsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetProcessErrorsDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get logs for a specific VNC process
pub async fn get_process_logs_deprecated(configuration: &configuration::Configuration, process_name: &str, sandbox_id: &str, x_daytona_organization_id: Option<&str>) -> Result<models::ProcessLogsResponse, Error<GetProcessLogsDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_process_name = process_name;
    let p_sandbox_id = sandbox_id;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/computeruse/process/{processName}/logs", configuration.base_path, processName=crate::apis::urlencode(p_process_name), sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProcessLogsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProcessLogsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetProcessLogsDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get status of a specific VNC process
pub async fn get_process_status_deprecated(configuration: &configuration::Configuration, process_name: &str, sandbox_id: &str, x_daytona_organization_id: Option<&str>) -> Result<models::ProcessStatusResponse, Error<GetProcessStatusDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_process_name = process_name;
    let p_sandbox_id = sandbox_id;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/computeruse/process/{processName}/status", configuration.base_path, processName=crate::apis::urlencode(p_process_name), sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProcessStatusResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProcessStatusResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetProcessStatusDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_project_dir_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, x_daytona_organization_id: Option<&str>) -> Result<models::ProjectDirResponse, Error<GetProjectDirDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/project-dir", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectDirResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectDirResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetProjectDirDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get PTY session information by ID
pub async fn get_pty_session_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, session_id: &str, x_daytona_organization_id: Option<&str>) -> Result<models::PtySessionInfo, Error<GetPtySessionDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_session_id = session_id;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/process/pty/{sessionId}", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id), sessionId=crate::apis::urlencode(p_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PtySessionInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PtySessionInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPtySessionDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get session command by ID
pub async fn get_session_command_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, session_id: &str, command_id: &str, x_daytona_organization_id: Option<&str>) -> Result<models::Command, Error<GetSessionCommandDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_session_id = session_id;
    let p_command_id = command_id;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/process/session/{sessionId}/command/{commandId}", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id), sessionId=crate::apis::urlencode(p_session_id), commandId=crate::apis::urlencode(p_command_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Command`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Command`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSessionCommandDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get logs for a specific command in a session
pub async fn get_session_command_logs_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, session_id: &str, command_id: &str, x_daytona_organization_id: Option<&str>, follow: Option<bool>) -> Result<String, Error<GetSessionCommandLogsDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_session_id = session_id;
    let p_command_id = command_id;
    let p_x_daytona_organization_id = x_daytona_organization_id;
    let p_follow = follow;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/process/session/{sessionId}/command/{commandId}/logs", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id), sessionId=crate::apis::urlencode(p_session_id), commandId=crate::apis::urlencode(p_command_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_follow {
        req_builder = req_builder.query(&[("follow", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Ok(content),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSessionCommandLogsDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get session by ID
pub async fn get_session_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, session_id: &str, x_daytona_organization_id: Option<&str>) -> Result<models::Session, Error<GetSessionDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_session_id = session_id;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/process/session/{sessionId}", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id), sessionId=crate::apis::urlencode(p_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Session`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Session`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSessionDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_user_home_dir_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, x_daytona_organization_id: Option<&str>) -> Result<models::UserHomeDirResponse, Error<GetUserHomeDirDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/user-home-dir", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserHomeDirResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserHomeDirResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUserHomeDirDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get list of open windows
pub async fn get_windows_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, x_daytona_organization_id: Option<&str>) -> Result<models::WindowsResponse, Error<GetWindowsDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/computeruse/display/windows", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WindowsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WindowsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWindowsDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_work_dir_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, x_daytona_organization_id: Option<&str>) -> Result<models::WorkDirResponse, Error<GetWorkDirDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/work-dir", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WorkDirResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WorkDirResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWorkDirDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Add files to git commit
pub async fn git_add_files_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, git_add_request: models::GitAddRequest, x_daytona_organization_id: Option<&str>) -> Result<(), Error<GitAddFilesDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_git_add_request = git_add_request;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/git/add", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_git_add_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GitAddFilesDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Checkout branch or commit in git repository
pub async fn git_checkout_branch_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, git_checkout_request: models::GitCheckoutRequest, x_daytona_organization_id: Option<&str>) -> Result<(), Error<GitCheckoutBranchDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_git_checkout_request = git_checkout_request;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/git/checkout", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_git_checkout_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GitCheckoutBranchDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Clone git repository
pub async fn git_clone_repository_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, git_clone_request: models::GitCloneRequest, x_daytona_organization_id: Option<&str>) -> Result<(), Error<GitCloneRepositoryDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_git_clone_request = git_clone_request;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/git/clone", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_git_clone_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GitCloneRepositoryDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Commit changes to git repository
pub async fn git_commit_changes_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, git_commit_request: models::GitCommitRequest, x_daytona_organization_id: Option<&str>) -> Result<models::GitCommitResponse, Error<GitCommitChangesDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_git_commit_request = git_commit_request;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/git/commit", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_git_commit_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GitCommitResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GitCommitResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GitCommitChangesDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create branch on git repository
pub async fn git_create_branch_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, git_branch_request: models::GitBranchRequest, x_daytona_organization_id: Option<&str>) -> Result<(), Error<GitCreateBranchDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_git_branch_request = git_branch_request;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/git/branches", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_git_branch_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GitCreateBranchDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete branch on git repository
pub async fn git_delete_branch_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, git_delete_branch_request: models::GitDeleteBranchRequest, x_daytona_organization_id: Option<&str>) -> Result<(), Error<GitDeleteBranchDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_git_delete_branch_request = git_delete_branch_request;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/git/branches", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_git_delete_branch_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GitDeleteBranchDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get commit history from git repository
pub async fn git_get_history_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, path: &str, x_daytona_organization_id: Option<&str>) -> Result<Vec<models::GitCommitInfo>, Error<GitGetHistoryDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_path = path;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/git/history", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("path", &p_path.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GitCommitInfo&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GitCommitInfo&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GitGetHistoryDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get status from git repository
pub async fn git_get_status_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, path: &str, x_daytona_organization_id: Option<&str>) -> Result<models::GitStatus, Error<GitGetStatusDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_path = path;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/git/status", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("path", &p_path.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GitStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GitStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GitGetStatusDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get branch list from git repository
pub async fn git_list_branches_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, path: &str, x_daytona_organization_id: Option<&str>) -> Result<models::ListBranchResponse, Error<GitListBranchesDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_path = path;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/git/branches", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("path", &p_path.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListBranchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListBranchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GitListBranchesDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Pull changes from remote
pub async fn git_pull_changes_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, git_repo_request: models::GitRepoRequest, x_daytona_organization_id: Option<&str>) -> Result<(), Error<GitPullChangesDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_git_repo_request = git_repo_request;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/git/pull", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_git_repo_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GitPullChangesDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Push changes to remote
pub async fn git_push_changes_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, git_repo_request: models::GitRepoRequest, x_daytona_organization_id: Option<&str>) -> Result<(), Error<GitPushChangesDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_git_repo_request = git_repo_request;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/git/push", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_git_repo_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GitPushChangesDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn list_files_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, x_daytona_organization_id: Option<&str>, path: Option<&str>) -> Result<Vec<models::FileInfo>, Error<ListFilesDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_x_daytona_organization_id = x_daytona_organization_id;
    let p_path = path;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/files", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_path {
        req_builder = req_builder.query(&[("path", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::FileInfo&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::FileInfo&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListFilesDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List all active PTY sessions in the sandbox
pub async fn list_pty_sessions_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, x_daytona_organization_id: Option<&str>) -> Result<models::PtyListResponse, Error<ListPtySessionsDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/process/pty", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PtyListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PtyListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListPtySessionsDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List all active sessions in the sandbox
pub async fn list_sessions_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, x_daytona_organization_id: Option<&str>) -> Result<Vec<models::Session>, Error<ListSessionsDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/process/session", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Session&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Session&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListSessionsDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The Completion request is sent from the client to the server to compute completion items at a given cursor position.
pub async fn lsp_completions_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, lsp_completion_params: models::LspCompletionParams, x_daytona_organization_id: Option<&str>) -> Result<models::CompletionList, Error<LspCompletionsDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_lsp_completion_params = lsp_completion_params;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/lsp/completions", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_lsp_completion_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CompletionList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CompletionList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LspCompletionsDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The document close notification is sent from the client to the server when the document got closed in the client.
pub async fn lsp_did_close_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, lsp_document_request: models::LspDocumentRequest, x_daytona_organization_id: Option<&str>) -> Result<(), Error<LspDidCloseDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_lsp_document_request = lsp_document_request;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/lsp/did-close", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_lsp_document_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<LspDidCloseDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The document open notification is sent from the client to the server to signal newly opened text documents.
pub async fn lsp_did_open_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, lsp_document_request: models::LspDocumentRequest, x_daytona_organization_id: Option<&str>) -> Result<(), Error<LspDidOpenDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_lsp_document_request = lsp_document_request;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/lsp/did-open", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_lsp_document_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<LspDidOpenDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The document symbol request is sent from the client to the server.
pub async fn lsp_document_symbols_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, language_id: &str, path_to_project: &str, uri: &str, x_daytona_organization_id: Option<&str>) -> Result<Vec<models::LspSymbol>, Error<LspDocumentSymbolsDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_language_id = language_id;
    let p_path_to_project = path_to_project;
    let p_uri = uri;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/lsp/document-symbols", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("languageId", &p_language_id.to_string())]);
    req_builder = req_builder.query(&[("pathToProject", &p_path_to_project.to_string())]);
    req_builder = req_builder.query(&[("uri", &p_uri.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::LspSymbol&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::LspSymbol&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LspDocumentSymbolsDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Start Lsp server process inside sandbox project
pub async fn lsp_start_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, lsp_server_request: models::LspServerRequest, x_daytona_organization_id: Option<&str>) -> Result<(), Error<LspStartDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_lsp_server_request = lsp_server_request;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/lsp/start", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_lsp_server_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<LspStartDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Stop Lsp server process inside sandbox project
pub async fn lsp_stop_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, lsp_server_request: models::LspServerRequest, x_daytona_organization_id: Option<&str>) -> Result<(), Error<LspStopDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_lsp_server_request = lsp_server_request;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/lsp/stop", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_lsp_server_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<LspStopDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The workspace symbol request is sent from the client to the server to list project-wide symbols matching the query string.
pub async fn lsp_workspace_symbols_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, language_id: &str, path_to_project: &str, query: &str, x_daytona_organization_id: Option<&str>) -> Result<Vec<models::LspSymbol>, Error<LspWorkspaceSymbolsDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_language_id = language_id;
    let p_path_to_project = path_to_project;
    let p_query = query;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/lsp/workspace-symbols", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("languageId", &p_language_id.to_string())]);
    req_builder = req_builder.query(&[("pathToProject", &p_path_to_project.to_string())]);
    req_builder = req_builder.query(&[("query", &p_query.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::LspSymbol&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::LspSymbol&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LspWorkspaceSymbolsDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Move file inside sandbox
pub async fn move_file_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, source: &str, destination: &str, x_daytona_organization_id: Option<&str>) -> Result<(), Error<MoveFileDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_source = source;
    let p_destination = destination;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/files/move", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("source", &p_source.to_string())]);
    req_builder = req_builder.query(&[("destination", &p_destination.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MoveFileDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Move mouse cursor to specified coordinates
pub async fn move_mouse_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, mouse_move_request: models::MouseMoveRequest, x_daytona_organization_id: Option<&str>) -> Result<models::MouseMoveResponse, Error<MoveMouseDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_mouse_move_request = mouse_move_request;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/computeruse/mouse/move", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_mouse_move_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MouseMoveResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MouseMoveResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MoveMouseDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Press a hotkey combination
pub async fn press_hotkey_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, keyboard_hotkey_request: models::KeyboardHotkeyRequest, x_daytona_organization_id: Option<&str>) -> Result<(), Error<PressHotkeyDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_keyboard_hotkey_request = keyboard_hotkey_request;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/computeruse/keyboard/hotkey", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_keyboard_hotkey_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PressHotkeyDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Press a key with optional modifiers
pub async fn press_key_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, keyboard_press_request: models::KeyboardPressRequest, x_daytona_organization_id: Option<&str>) -> Result<(), Error<PressKeyDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_keyboard_press_request = keyboard_press_request;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/computeruse/keyboard/key", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_keyboard_press_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PressKeyDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Replace text/pattern in multiple files inside sandbox
pub async fn replace_in_files_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, replace_request: models::ReplaceRequest, x_daytona_organization_id: Option<&str>) -> Result<Vec<models::ReplaceResult>, Error<ReplaceInFilesDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_replace_request = replace_request;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/files/replace", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_replace_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ReplaceResult&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ReplaceResult&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReplaceInFilesDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Resize a PTY session
pub async fn resize_pty_session_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, session_id: &str, pty_resize_request: models::PtyResizeRequest, x_daytona_organization_id: Option<&str>) -> Result<models::PtySessionInfo, Error<ResizePtySessionDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_session_id = session_id;
    let p_pty_resize_request = pty_resize_request;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/process/pty/{sessionId}/resize", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id), sessionId=crate::apis::urlencode(p_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_pty_resize_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PtySessionInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PtySessionInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ResizePtySessionDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Restart a specific VNC process
pub async fn restart_process_deprecated(configuration: &configuration::Configuration, process_name: &str, sandbox_id: &str, x_daytona_organization_id: Option<&str>) -> Result<models::ProcessRestartResponse, Error<RestartProcessDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_process_name = process_name;
    let p_sandbox_id = sandbox_id;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/computeruse/process/{processName}/restart", configuration.base_path, processName=crate::apis::urlencode(p_process_name), sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProcessRestartResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProcessRestartResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RestartProcessDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Scroll mouse at specified coordinates
pub async fn scroll_mouse_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, mouse_scroll_request: models::MouseScrollRequest, x_daytona_organization_id: Option<&str>) -> Result<models::MouseScrollResponse, Error<ScrollMouseDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_mouse_scroll_request = mouse_scroll_request;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/computeruse/mouse/scroll", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_mouse_scroll_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MouseScrollResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MouseScrollResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ScrollMouseDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search for files inside sandbox
pub async fn search_files_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, path: &str, pattern: &str, x_daytona_organization_id: Option<&str>) -> Result<models::SearchFilesResponse, Error<SearchFilesDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_path = path;
    let p_pattern = pattern;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/files/search", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("path", &p_path.to_string())]);
    req_builder = req_builder.query(&[("pattern", &p_pattern.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SearchFilesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SearchFilesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchFilesDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Set file owner/group/permissions inside sandbox
pub async fn set_file_permissions_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, path: &str, x_daytona_organization_id: Option<&str>, owner: Option<&str>, group: Option<&str>, mode: Option<&str>) -> Result<(), Error<SetFilePermissionsDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_path = path;
    let p_x_daytona_organization_id = x_daytona_organization_id;
    let p_owner = owner;
    let p_group = group;
    let p_mode = mode;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/files/permissions", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("path", &p_path.to_string())]);
    if let Some(ref param_value) = p_owner {
        req_builder = req_builder.query(&[("owner", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_group {
        req_builder = req_builder.query(&[("group", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_mode {
        req_builder = req_builder.query(&[("mode", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SetFilePermissionsDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Start all VNC desktop processes (Xvfb, xfce4, x11vnc, novnc)
pub async fn start_computer_use_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, x_daytona_organization_id: Option<&str>) -> Result<models::ComputerUseStartResponse, Error<StartComputerUseDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/computeruse/start", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ComputerUseStartResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ComputerUseStartResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StartComputerUseDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Stop all VNC desktop processes (Xvfb, xfce4, x11vnc, novnc)
pub async fn stop_computer_use_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, x_daytona_organization_id: Option<&str>) -> Result<models::ComputerUseStopResponse, Error<StopComputerUseDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/computeruse/stop", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ComputerUseStopResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ComputerUseStopResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StopComputerUseDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Take a compressed screenshot of a specific region
pub async fn take_compressed_region_screenshot_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, height: f64, width: f64, y: f64, x: f64, x_daytona_organization_id: Option<&str>, scale: Option<f64>, quality: Option<f64>, format: Option<&str>, show_cursor: Option<bool>) -> Result<models::CompressedScreenshotResponse, Error<TakeCompressedRegionScreenshotDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_height = height;
    let p_width = width;
    let p_y = y;
    let p_x = x;
    let p_x_daytona_organization_id = x_daytona_organization_id;
    let p_scale = scale;
    let p_quality = quality;
    let p_format = format;
    let p_show_cursor = show_cursor;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/computeruse/screenshot/region/compressed", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_scale {
        req_builder = req_builder.query(&[("scale", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_quality {
        req_builder = req_builder.query(&[("quality", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_show_cursor {
        req_builder = req_builder.query(&[("show_cursor", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("height", &p_height.to_string())]);
    req_builder = req_builder.query(&[("width", &p_width.to_string())]);
    req_builder = req_builder.query(&[("y", &p_y.to_string())]);
    req_builder = req_builder.query(&[("x", &p_x.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CompressedScreenshotResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CompressedScreenshotResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TakeCompressedRegionScreenshotDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Take a compressed screenshot with format, quality, and scale options
pub async fn take_compressed_screenshot_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, x_daytona_organization_id: Option<&str>, scale: Option<f64>, quality: Option<f64>, format: Option<&str>, show_cursor: Option<bool>) -> Result<models::CompressedScreenshotResponse, Error<TakeCompressedScreenshotDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_x_daytona_organization_id = x_daytona_organization_id;
    let p_scale = scale;
    let p_quality = quality;
    let p_format = format;
    let p_show_cursor = show_cursor;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/computeruse/screenshot/compressed", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_scale {
        req_builder = req_builder.query(&[("scale", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_quality {
        req_builder = req_builder.query(&[("quality", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_show_cursor {
        req_builder = req_builder.query(&[("show_cursor", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CompressedScreenshotResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CompressedScreenshotResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TakeCompressedScreenshotDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Take a screenshot of a specific region
pub async fn take_region_screenshot_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, height: f64, width: f64, y: f64, x: f64, x_daytona_organization_id: Option<&str>, show_cursor: Option<bool>) -> Result<models::RegionScreenshotResponse, Error<TakeRegionScreenshotDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_height = height;
    let p_width = width;
    let p_y = y;
    let p_x = x;
    let p_x_daytona_organization_id = x_daytona_organization_id;
    let p_show_cursor = show_cursor;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/computeruse/screenshot/region", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_show_cursor {
        req_builder = req_builder.query(&[("show_cursor", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("height", &p_height.to_string())]);
    req_builder = req_builder.query(&[("width", &p_width.to_string())]);
    req_builder = req_builder.query(&[("y", &p_y.to_string())]);
    req_builder = req_builder.query(&[("x", &p_x.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RegionScreenshotResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RegionScreenshotResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TakeRegionScreenshotDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Take a screenshot of the entire screen
pub async fn take_screenshot_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, x_daytona_organization_id: Option<&str>, show_cursor: Option<bool>) -> Result<models::ScreenshotResponse, Error<TakeScreenshotDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_x_daytona_organization_id = x_daytona_organization_id;
    let p_show_cursor = show_cursor;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/computeruse/screenshot", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_show_cursor {
        req_builder = req_builder.query(&[("show_cursor", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScreenshotResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScreenshotResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TakeScreenshotDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Type text using keyboard
pub async fn type_text_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, keyboard_type_request: models::KeyboardTypeRequest, x_daytona_organization_id: Option<&str>) -> Result<(), Error<TypeTextDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_keyboard_type_request = keyboard_type_request;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/computeruse/keyboard/type", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_keyboard_type_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<TypeTextDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Upload file inside sandbox
pub async fn upload_file_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, path: &str, x_daytona_organization_id: Option<&str>, file: Option<std::path::PathBuf>) -> Result<(), Error<UploadFileDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_path = path;
    let p_x_daytona_organization_id = x_daytona_organization_id;
    let p_file = file;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/files/upload", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("path", &p_path.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    let mut multipart_form = reqwest::multipart::Form::new();
    // TODO: support file upload for 'file' parameter
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UploadFileDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Upload multiple files inside sandbox
pub async fn upload_files_deprecated(configuration: &configuration::Configuration, sandbox_id: &str, x_daytona_organization_id: Option<&str>) -> Result<(), Error<UploadFilesDeprecatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/toolbox/{sandboxId}/toolbox/files/bulk-upload", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UploadFilesDeprecatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

