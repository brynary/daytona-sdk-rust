/*
 * Daytona
 *
 * Daytona AI platform API Docs
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@daytona.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`archive_sandbox`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ArchiveSandboxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_backup`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateBackupError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_sandbox`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSandboxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_ssh_access`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSshAccessError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_sandbox`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSandboxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`expire_signed_port_preview_url`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExpireSignedPortPreviewUrlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_build_logs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBuildLogsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_build_logs_url`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBuildLogsUrlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_port_preview_url`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPortPreviewUrlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_sandbox`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSandboxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_sandbox_logs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSandboxLogsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_sandbox_metrics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSandboxMetricsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_sandbox_trace_spans`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSandboxTraceSpansError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_sandbox_traces`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSandboxTracesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_sandboxes_for_runner`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSandboxesForRunnerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_signed_port_preview_url`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSignedPortPreviewUrlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_toolbox_proxy_url`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetToolboxProxyUrlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_sandboxes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSandboxesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_sandboxes_paginated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSandboxesPaginatedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`recover_sandbox`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RecoverSandboxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`replace_labels`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReplaceLabelsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`resize_sandbox`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResizeSandboxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`revoke_ssh_access`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevokeSshAccessError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_auto_archive_interval`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetAutoArchiveIntervalError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_auto_delete_interval`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetAutoDeleteIntervalError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_autostop_interval`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetAutostopIntervalError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_sandbox`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartSandboxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stop_sandbox`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StopSandboxError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_last_activity`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateLastActivityError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_public_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdatePublicStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_sandbox_state`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSandboxStateError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`validate_ssh_access`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ValidateSshAccessError {
    UnknownValue(serde_json::Value),
}


pub async fn archive_sandbox(configuration: &configuration::Configuration, sandbox_id_or_name: &str, x_daytona_organization_id: Option<&str>) -> Result<models::Sandbox, Error<ArchiveSandboxError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id_or_name = sandbox_id_or_name;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/sandbox/{sandboxIdOrName}/archive", configuration.base_path, sandboxIdOrName=crate::apis::urlencode(p_sandbox_id_or_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Sandbox`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Sandbox`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ArchiveSandboxError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_backup(configuration: &configuration::Configuration, sandbox_id_or_name: &str, x_daytona_organization_id: Option<&str>) -> Result<models::Sandbox, Error<CreateBackupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id_or_name = sandbox_id_or_name;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/sandbox/{sandboxIdOrName}/backup", configuration.base_path, sandboxIdOrName=crate::apis::urlencode(p_sandbox_id_or_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Sandbox`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Sandbox`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateBackupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_sandbox(configuration: &configuration::Configuration, create_sandbox: models::CreateSandbox, x_daytona_organization_id: Option<&str>) -> Result<models::Sandbox, Error<CreateSandboxError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_create_sandbox = create_sandbox;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/sandbox", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_create_sandbox);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Sandbox`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Sandbox`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSandboxError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_ssh_access(configuration: &configuration::Configuration, sandbox_id_or_name: &str, x_daytona_organization_id: Option<&str>, expires_in_minutes: Option<f64>) -> Result<models::SshAccessDto, Error<CreateSshAccessError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id_or_name = sandbox_id_or_name;
    let p_x_daytona_organization_id = x_daytona_organization_id;
    let p_expires_in_minutes = expires_in_minutes;

    let uri_str = format!("{}/sandbox/{sandboxIdOrName}/ssh-access", configuration.base_path, sandboxIdOrName=crate::apis::urlencode(p_sandbox_id_or_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_expires_in_minutes {
        req_builder = req_builder.query(&[("expiresInMinutes", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SshAccessDto`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SshAccessDto`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSshAccessError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_sandbox(configuration: &configuration::Configuration, sandbox_id_or_name: &str, x_daytona_organization_id: Option<&str>) -> Result<models::Sandbox, Error<DeleteSandboxError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id_or_name = sandbox_id_or_name;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/sandbox/{sandboxIdOrName}", configuration.base_path, sandboxIdOrName=crate::apis::urlencode(p_sandbox_id_or_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Sandbox`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Sandbox`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteSandboxError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn expire_signed_port_preview_url(configuration: &configuration::Configuration, sandbox_id_or_name: &str, port: i32, token: &str, x_daytona_organization_id: Option<&str>) -> Result<(), Error<ExpireSignedPortPreviewUrlError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id_or_name = sandbox_id_or_name;
    let p_port = port;
    let p_token = token;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/sandbox/{sandboxIdOrName}/ports/{port}/signed-preview-url/{token}/expire", configuration.base_path, sandboxIdOrName=crate::apis::urlencode(p_sandbox_id_or_name), port=p_port, token=crate::apis::urlencode(p_token));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ExpireSignedPortPreviewUrlError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint is deprecated. Use `getBuildLogsUrl` instead.
pub async fn get_build_logs(configuration: &configuration::Configuration, sandbox_id_or_name: &str, x_daytona_organization_id: Option<&str>, follow: Option<bool>) -> Result<(), Error<GetBuildLogsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id_or_name = sandbox_id_or_name;
    let p_x_daytona_organization_id = x_daytona_organization_id;
    let p_follow = follow;

    let uri_str = format!("{}/sandbox/{sandboxIdOrName}/build-logs", configuration.base_path, sandboxIdOrName=crate::apis::urlencode(p_sandbox_id_or_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_follow {
        req_builder = req_builder.query(&[("follow", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBuildLogsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_build_logs_url(configuration: &configuration::Configuration, sandbox_id_or_name: &str, x_daytona_organization_id: Option<&str>) -> Result<models::Url, Error<GetBuildLogsUrlError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id_or_name = sandbox_id_or_name;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/sandbox/{sandboxIdOrName}/build-logs-url", configuration.base_path, sandboxIdOrName=crate::apis::urlencode(p_sandbox_id_or_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Url`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Url`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBuildLogsUrlError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_port_preview_url(configuration: &configuration::Configuration, sandbox_id_or_name: &str, port: f64, x_daytona_organization_id: Option<&str>) -> Result<models::PortPreviewUrl, Error<GetPortPreviewUrlError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id_or_name = sandbox_id_or_name;
    let p_port = port;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/sandbox/{sandboxIdOrName}/ports/{port}/preview-url", configuration.base_path, sandboxIdOrName=crate::apis::urlencode(p_sandbox_id_or_name), port=p_port);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PortPreviewUrl`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PortPreviewUrl`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPortPreviewUrlError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_sandbox(configuration: &configuration::Configuration, sandbox_id_or_name: &str, x_daytona_organization_id: Option<&str>, verbose: Option<bool>) -> Result<models::Sandbox, Error<GetSandboxError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id_or_name = sandbox_id_or_name;
    let p_x_daytona_organization_id = x_daytona_organization_id;
    let p_verbose = verbose;

    let uri_str = format!("{}/sandbox/{sandboxIdOrName}", configuration.base_path, sandboxIdOrName=crate::apis::urlencode(p_sandbox_id_or_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_verbose {
        req_builder = req_builder.query(&[("verbose", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Sandbox`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Sandbox`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSandboxError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve OTEL logs for a sandbox within a time range
pub async fn get_sandbox_logs(configuration: &configuration::Configuration, sandbox_id: &str, from: String, to: String, x_daytona_organization_id: Option<&str>, page: Option<f64>, limit: Option<f64>, severities: Option<Vec<String>>, search: Option<&str>) -> Result<models::PaginatedLogs, Error<GetSandboxLogsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_from = from;
    let p_to = to;
    let p_x_daytona_organization_id = x_daytona_organization_id;
    let p_page = page;
    let p_limit = limit;
    let p_severities = severities;
    let p_search = search;

    let uri_str = format!("{}/sandbox/{sandboxId}/telemetry/logs", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("from", &p_from.to_string())]);
    req_builder = req_builder.query(&[("to", &p_to.to_string())]);
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_severities {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("severities".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("severities", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedLogs`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedLogs`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSandboxLogsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve OTEL metrics for a sandbox within a time range
pub async fn get_sandbox_metrics(configuration: &configuration::Configuration, sandbox_id: &str, from: String, to: String, x_daytona_organization_id: Option<&str>, metric_names: Option<Vec<String>>) -> Result<models::MetricsResponse, Error<GetSandboxMetricsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_from = from;
    let p_to = to;
    let p_x_daytona_organization_id = x_daytona_organization_id;
    let p_metric_names = metric_names;

    let uri_str = format!("{}/sandbox/{sandboxId}/telemetry/metrics", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("from", &p_from.to_string())]);
    req_builder = req_builder.query(&[("to", &p_to.to_string())]);
    if let Some(ref param_value) = p_metric_names {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("metricNames".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("metricNames", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MetricsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MetricsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSandboxMetricsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve all spans for a specific trace
pub async fn get_sandbox_trace_spans(configuration: &configuration::Configuration, sandbox_id: &str, trace_id: &str, x_daytona_organization_id: Option<&str>) -> Result<Vec<models::TraceSpan>, Error<GetSandboxTraceSpansError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_trace_id = trace_id;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/sandbox/{sandboxId}/telemetry/traces/{traceId}", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id), traceId=crate::apis::urlencode(p_trace_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::TraceSpan&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::TraceSpan&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSandboxTraceSpansError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve OTEL traces for a sandbox within a time range
pub async fn get_sandbox_traces(configuration: &configuration::Configuration, sandbox_id: &str, from: String, to: String, x_daytona_organization_id: Option<&str>, page: Option<f64>, limit: Option<f64>) -> Result<models::PaginatedTraces, Error<GetSandboxTracesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_from = from;
    let p_to = to;
    let p_x_daytona_organization_id = x_daytona_organization_id;
    let p_page = page;
    let p_limit = limit;

    let uri_str = format!("{}/sandbox/{sandboxId}/telemetry/traces", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("from", &p_from.to_string())]);
    req_builder = req_builder.query(&[("to", &p_to.to_string())]);
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedTraces`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedTraces`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSandboxTracesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_sandboxes_for_runner(configuration: &configuration::Configuration, x_daytona_organization_id: Option<&str>, states: Option<&str>, skip_reconciling_sandboxes: Option<bool>) -> Result<Vec<models::Sandbox>, Error<GetSandboxesForRunnerError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x_daytona_organization_id = x_daytona_organization_id;
    let p_states = states;
    let p_skip_reconciling_sandboxes = skip_reconciling_sandboxes;

    let uri_str = format!("{}/sandbox/for-runner", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_states {
        req_builder = req_builder.query(&[("states", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip_reconciling_sandboxes {
        req_builder = req_builder.query(&[("skipReconcilingSandboxes", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Sandbox&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Sandbox&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSandboxesForRunnerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_signed_port_preview_url(configuration: &configuration::Configuration, sandbox_id_or_name: &str, port: i32, x_daytona_organization_id: Option<&str>, expires_in_seconds: Option<i32>) -> Result<models::SignedPortPreviewUrl, Error<GetSignedPortPreviewUrlError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id_or_name = sandbox_id_or_name;
    let p_port = port;
    let p_x_daytona_organization_id = x_daytona_organization_id;
    let p_expires_in_seconds = expires_in_seconds;

    let uri_str = format!("{}/sandbox/{sandboxIdOrName}/ports/{port}/signed-preview-url", configuration.base_path, sandboxIdOrName=crate::apis::urlencode(p_sandbox_id_or_name), port=p_port);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_expires_in_seconds {
        req_builder = req_builder.query(&[("expiresInSeconds", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SignedPortPreviewUrl`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SignedPortPreviewUrl`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSignedPortPreviewUrlError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_toolbox_proxy_url(configuration: &configuration::Configuration, sandbox_id: &str, x_daytona_organization_id: Option<&str>) -> Result<models::ToolboxProxyUrl, Error<GetToolboxProxyUrlError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/sandbox/{sandboxId}/toolbox-proxy-url", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ToolboxProxyUrl`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ToolboxProxyUrl`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetToolboxProxyUrlError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn list_sandboxes(configuration: &configuration::Configuration, x_daytona_organization_id: Option<&str>, verbose: Option<bool>, labels: Option<&str>, include_errored_deleted: Option<bool>) -> Result<Vec<models::Sandbox>, Error<ListSandboxesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x_daytona_organization_id = x_daytona_organization_id;
    let p_verbose = verbose;
    let p_labels = labels;
    let p_include_errored_deleted = include_errored_deleted;

    let uri_str = format!("{}/sandbox", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_verbose {
        req_builder = req_builder.query(&[("verbose", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_labels {
        req_builder = req_builder.query(&[("labels", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_errored_deleted {
        req_builder = req_builder.query(&[("includeErroredDeleted", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Sandbox&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Sandbox&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListSandboxesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn list_sandboxes_paginated(configuration: &configuration::Configuration, x_daytona_organization_id: Option<&str>, page: Option<f64>, limit: Option<f64>, id: Option<&str>, name: Option<&str>, labels: Option<&str>, include_errored_deleted: Option<bool>, states: Option<Vec<String>>, snapshots: Option<Vec<String>>, regions: Option<Vec<String>>, min_cpu: Option<f64>, max_cpu: Option<f64>, min_memory_gi_b: Option<f64>, max_memory_gi_b: Option<f64>, min_disk_gi_b: Option<f64>, max_disk_gi_b: Option<f64>, last_event_after: Option<String>, last_event_before: Option<String>, sort: Option<&str>, order: Option<&str>) -> Result<models::PaginatedSandboxes, Error<ListSandboxesPaginatedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x_daytona_organization_id = x_daytona_organization_id;
    let p_page = page;
    let p_limit = limit;
    let p_id = id;
    let p_name = name;
    let p_labels = labels;
    let p_include_errored_deleted = include_errored_deleted;
    let p_states = states;
    let p_snapshots = snapshots;
    let p_regions = regions;
    let p_min_cpu = min_cpu;
    let p_max_cpu = max_cpu;
    let p_min_memory_gi_b = min_memory_gi_b;
    let p_max_memory_gi_b = max_memory_gi_b;
    let p_min_disk_gi_b = min_disk_gi_b;
    let p_max_disk_gi_b = max_disk_gi_b;
    let p_last_event_after = last_event_after;
    let p_last_event_before = last_event_before;
    let p_sort = sort;
    let p_order = order;

    let uri_str = format!("{}/sandbox/paginated", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_id {
        req_builder = req_builder.query(&[("id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_labels {
        req_builder = req_builder.query(&[("labels", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_errored_deleted {
        req_builder = req_builder.query(&[("includeErroredDeleted", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_states {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("states".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("states", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_snapshots {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("snapshots".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("snapshots", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_regions {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("regions".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("regions", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_min_cpu {
        req_builder = req_builder.query(&[("minCpu", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_max_cpu {
        req_builder = req_builder.query(&[("maxCpu", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_min_memory_gi_b {
        req_builder = req_builder.query(&[("minMemoryGiB", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_max_memory_gi_b {
        req_builder = req_builder.query(&[("maxMemoryGiB", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_min_disk_gi_b {
        req_builder = req_builder.query(&[("minDiskGiB", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_max_disk_gi_b {
        req_builder = req_builder.query(&[("maxDiskGiB", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_last_event_after {
        req_builder = req_builder.query(&[("lastEventAfter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_last_event_before {
        req_builder = req_builder.query(&[("lastEventBefore", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_order {
        req_builder = req_builder.query(&[("order", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedSandboxes`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedSandboxes`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListSandboxesPaginatedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn recover_sandbox(configuration: &configuration::Configuration, sandbox_id_or_name: &str, x_daytona_organization_id: Option<&str>) -> Result<models::Sandbox, Error<RecoverSandboxError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id_or_name = sandbox_id_or_name;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/sandbox/{sandboxIdOrName}/recover", configuration.base_path, sandboxIdOrName=crate::apis::urlencode(p_sandbox_id_or_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Sandbox`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Sandbox`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RecoverSandboxError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn replace_labels(configuration: &configuration::Configuration, sandbox_id_or_name: &str, sandbox_labels: models::SandboxLabels, x_daytona_organization_id: Option<&str>) -> Result<models::SandboxLabels, Error<ReplaceLabelsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id_or_name = sandbox_id_or_name;
    let p_sandbox_labels = sandbox_labels;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/sandbox/{sandboxIdOrName}/labels", configuration.base_path, sandboxIdOrName=crate::apis::urlencode(p_sandbox_id_or_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_sandbox_labels);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SandboxLabels`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SandboxLabels`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ReplaceLabelsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn resize_sandbox(configuration: &configuration::Configuration, sandbox_id_or_name: &str, resize_sandbox: models::ResizeSandbox, x_daytona_organization_id: Option<&str>) -> Result<models::Sandbox, Error<ResizeSandboxError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id_or_name = sandbox_id_or_name;
    let p_resize_sandbox = resize_sandbox;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/sandbox/{sandboxIdOrName}/resize", configuration.base_path, sandboxIdOrName=crate::apis::urlencode(p_sandbox_id_or_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_resize_sandbox);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Sandbox`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Sandbox`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ResizeSandboxError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn revoke_ssh_access(configuration: &configuration::Configuration, sandbox_id_or_name: &str, x_daytona_organization_id: Option<&str>, token: Option<&str>) -> Result<models::Sandbox, Error<RevokeSshAccessError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id_or_name = sandbox_id_or_name;
    let p_x_daytona_organization_id = x_daytona_organization_id;
    let p_token = token;

    let uri_str = format!("{}/sandbox/{sandboxIdOrName}/ssh-access", configuration.base_path, sandboxIdOrName=crate::apis::urlencode(p_sandbox_id_or_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_token {
        req_builder = req_builder.query(&[("token", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Sandbox`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Sandbox`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RevokeSshAccessError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn set_auto_archive_interval(configuration: &configuration::Configuration, sandbox_id_or_name: &str, interval: f64, x_daytona_organization_id: Option<&str>) -> Result<models::Sandbox, Error<SetAutoArchiveIntervalError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id_or_name = sandbox_id_or_name;
    let p_interval = interval;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/sandbox/{sandboxIdOrName}/autoarchive/{interval}", configuration.base_path, sandboxIdOrName=crate::apis::urlencode(p_sandbox_id_or_name), interval=p_interval);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Sandbox`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Sandbox`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SetAutoArchiveIntervalError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn set_auto_delete_interval(configuration: &configuration::Configuration, sandbox_id_or_name: &str, interval: f64, x_daytona_organization_id: Option<&str>) -> Result<models::Sandbox, Error<SetAutoDeleteIntervalError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id_or_name = sandbox_id_or_name;
    let p_interval = interval;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/sandbox/{sandboxIdOrName}/autodelete/{interval}", configuration.base_path, sandboxIdOrName=crate::apis::urlencode(p_sandbox_id_or_name), interval=p_interval);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Sandbox`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Sandbox`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SetAutoDeleteIntervalError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn set_autostop_interval(configuration: &configuration::Configuration, sandbox_id_or_name: &str, interval: f64, x_daytona_organization_id: Option<&str>) -> Result<models::Sandbox, Error<SetAutostopIntervalError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id_or_name = sandbox_id_or_name;
    let p_interval = interval;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/sandbox/{sandboxIdOrName}/autostop/{interval}", configuration.base_path, sandboxIdOrName=crate::apis::urlencode(p_sandbox_id_or_name), interval=p_interval);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Sandbox`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Sandbox`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SetAutostopIntervalError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn start_sandbox(configuration: &configuration::Configuration, sandbox_id_or_name: &str, x_daytona_organization_id: Option<&str>) -> Result<models::Sandbox, Error<StartSandboxError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id_or_name = sandbox_id_or_name;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/sandbox/{sandboxIdOrName}/start", configuration.base_path, sandboxIdOrName=crate::apis::urlencode(p_sandbox_id_or_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Sandbox`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Sandbox`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StartSandboxError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn stop_sandbox(configuration: &configuration::Configuration, sandbox_id_or_name: &str, x_daytona_organization_id: Option<&str>) -> Result<models::Sandbox, Error<StopSandboxError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id_or_name = sandbox_id_or_name;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/sandbox/{sandboxIdOrName}/stop", configuration.base_path, sandboxIdOrName=crate::apis::urlencode(p_sandbox_id_or_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Sandbox`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Sandbox`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StopSandboxError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn update_last_activity(configuration: &configuration::Configuration, sandbox_id: &str, x_daytona_organization_id: Option<&str>) -> Result<(), Error<UpdateLastActivityError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/sandbox/{sandboxId}/last-activity", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateLastActivityError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn update_public_status(configuration: &configuration::Configuration, sandbox_id_or_name: &str, is_public: bool, x_daytona_organization_id: Option<&str>) -> Result<models::Sandbox, Error<UpdatePublicStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id_or_name = sandbox_id_or_name;
    let p_is_public = is_public;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/sandbox/{sandboxIdOrName}/public/{isPublic}", configuration.base_path, sandboxIdOrName=crate::apis::urlencode(p_sandbox_id_or_name), isPublic=p_is_public);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Sandbox`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Sandbox`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdatePublicStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn update_sandbox_state(configuration: &configuration::Configuration, sandbox_id: &str, update_sandbox_state_dto: models::UpdateSandboxStateDto, x_daytona_organization_id: Option<&str>) -> Result<(), Error<UpdateSandboxStateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sandbox_id = sandbox_id;
    let p_update_sandbox_state_dto = update_sandbox_state_dto;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/sandbox/{sandboxId}/state", configuration.base_path, sandboxId=crate::apis::urlencode(p_sandbox_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_sandbox_state_dto);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateSandboxStateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn validate_ssh_access(configuration: &configuration::Configuration, token: &str, x_daytona_organization_id: Option<&str>) -> Result<models::SshAccessValidationDto, Error<ValidateSshAccessError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_token = token;
    let p_x_daytona_organization_id = x_daytona_organization_id;

    let uri_str = format!("{}/sandbox/ssh-access/validate", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("token", &p_token.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_daytona_organization_id {
        req_builder = req_builder.header("X-Daytona-Organization-ID", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SshAccessValidationDto`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SshAccessValidationDto`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ValidateSshAccessError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

