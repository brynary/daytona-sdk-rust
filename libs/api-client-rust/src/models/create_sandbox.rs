/*
 * Daytona
 *
 * Daytona AI platform API Docs
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@daytona.com
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct CreateSandbox {
    /// The name of the sandbox. If not provided, the sandbox ID will be used as the name
    #[serde(rename = "name", skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// The ID or name of the snapshot used for the sandbox
    #[serde(rename = "snapshot", skip_serializing_if = "Option::is_none")]
    pub snapshot: Option<String>,
    /// The user associated with the project
    #[serde(rename = "user", skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
    /// Environment variables for the sandbox
    #[serde(rename = "env", skip_serializing_if = "Option::is_none")]
    pub env: Option<std::collections::HashMap<String, String>>,
    /// Labels for the sandbox
    #[serde(rename = "labels", skip_serializing_if = "Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,
    /// Whether the sandbox http preview is publicly accessible
    #[serde(rename = "public", skip_serializing_if = "Option::is_none")]
    pub public: Option<bool>,
    /// Whether to block all network access for the sandbox
    #[serde(rename = "networkBlockAll", skip_serializing_if = "Option::is_none")]
    pub network_block_all: Option<bool>,
    /// Comma-separated list of allowed CIDR network addresses for the sandbox
    #[serde(rename = "networkAllowList", skip_serializing_if = "Option::is_none")]
    pub network_allow_list: Option<String>,
    /// The sandbox class type
    #[serde(rename = "class", skip_serializing_if = "Option::is_none")]
    pub class: Option<Class>,
    /// The target (region) where the sandbox will be created
    #[serde(rename = "target", skip_serializing_if = "Option::is_none")]
    pub target: Option<String>,
    /// CPU cores allocated to the sandbox
    #[serde(rename = "cpu", skip_serializing_if = "Option::is_none")]
    pub cpu: Option<i32>,
    /// GPU units allocated to the sandbox
    #[serde(rename = "gpu", skip_serializing_if = "Option::is_none")]
    pub gpu: Option<i32>,
    /// Memory allocated to the sandbox in GB
    #[serde(rename = "memory", skip_serializing_if = "Option::is_none")]
    pub memory: Option<i32>,
    /// Disk space allocated to the sandbox in GB
    #[serde(rename = "disk", skip_serializing_if = "Option::is_none")]
    pub disk: Option<i32>,
    /// Auto-stop interval in minutes (0 means disabled)
    #[serde(rename = "autoStopInterval", skip_serializing_if = "Option::is_none")]
    pub auto_stop_interval: Option<i32>,
    /// Auto-archive interval in minutes (0 means the maximum interval will be used)
    #[serde(rename = "autoArchiveInterval", skip_serializing_if = "Option::is_none")]
    pub auto_archive_interval: Option<i32>,
    /// Auto-delete interval in minutes (negative value means disabled, 0 means delete immediately upon stopping)
    #[serde(rename = "autoDeleteInterval", skip_serializing_if = "Option::is_none")]
    pub auto_delete_interval: Option<i32>,
    /// Array of volumes to attach to the sandbox
    #[serde(rename = "volumes", skip_serializing_if = "Option::is_none")]
    pub volumes: Option<Vec<models::SandboxVolume>>,
    /// Build information for the sandbox
    #[serde(rename = "buildInfo", skip_serializing_if = "Option::is_none")]
    pub build_info: Option<Box<models::CreateBuildInfo>>,
}

impl CreateSandbox {
    pub fn new() -> CreateSandbox {
        CreateSandbox {
            name: None,
            snapshot: None,
            user: None,
            env: None,
            labels: None,
            public: None,
            network_block_all: None,
            network_allow_list: None,
            class: None,
            target: None,
            cpu: None,
            gpu: None,
            memory: None,
            disk: None,
            auto_stop_interval: None,
            auto_archive_interval: None,
            auto_delete_interval: None,
            volumes: None,
            build_info: None,
        }
    }
}
/// The sandbox class type
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum Class {
    #[serde(rename = "small")]
    Small,
    #[serde(rename = "medium")]
    Medium,
    #[serde(rename = "large")]
    Large,
}

impl Default for Class {
    fn default() -> Class {
        Self::Small
    }
}

