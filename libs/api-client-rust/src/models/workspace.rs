/*
 * Daytona
 *
 * Daytona AI platform API Docs
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@daytona.com
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct Workspace {
    /// The ID of the sandbox
    #[serde(rename = "id")]
    pub id: String,
    /// The organization ID of the sandbox
    #[serde(rename = "organizationId")]
    pub organization_id: String,
    /// The name of the sandbox
    #[serde(rename = "name")]
    pub name: String,
    /// The snapshot used for the sandbox
    #[serde(rename = "snapshot", skip_serializing_if = "Option::is_none")]
    pub snapshot: Option<String>,
    /// The user associated with the project
    #[serde(rename = "user")]
    pub user: String,
    /// Environment variables for the sandbox
    #[serde(rename = "env")]
    pub env: std::collections::HashMap<String, String>,
    /// Labels for the sandbox
    #[serde(rename = "labels")]
    pub labels: std::collections::HashMap<String, String>,
    /// Whether the sandbox http preview is public
    #[serde(rename = "public")]
    pub public: bool,
    /// Whether to block all network access for the sandbox
    #[serde(rename = "networkBlockAll")]
    pub network_block_all: bool,
    /// Comma-separated list of allowed CIDR network addresses for the sandbox
    #[serde(rename = "networkAllowList", skip_serializing_if = "Option::is_none")]
    pub network_allow_list: Option<String>,
    /// The target environment for the sandbox
    #[serde(rename = "target")]
    pub target: String,
    /// The CPU quota for the sandbox
    #[serde(rename = "cpu")]
    pub cpu: f64,
    /// The GPU quota for the sandbox
    #[serde(rename = "gpu")]
    pub gpu: f64,
    /// The memory quota for the sandbox
    #[serde(rename = "memory")]
    pub memory: f64,
    /// The disk quota for the sandbox
    #[serde(rename = "disk")]
    pub disk: f64,
    /// The state of the sandbox
    #[serde(rename = "state", skip_serializing_if = "Option::is_none")]
    pub state: Option<models::SandboxState>,
    /// The desired state of the sandbox
    #[serde(rename = "desiredState", skip_serializing_if = "Option::is_none")]
    pub desired_state: Option<models::SandboxDesiredState>,
    /// The error reason of the sandbox
    #[serde(rename = "errorReason", skip_serializing_if = "Option::is_none")]
    pub error_reason: Option<String>,
    /// Whether the sandbox error is recoverable.
    #[serde(rename = "recoverable", skip_serializing_if = "Option::is_none")]
    pub recoverable: Option<bool>,
    /// The state of the backup
    #[serde(rename = "backupState", skip_serializing_if = "Option::is_none")]
    pub backup_state: Option<BackupState>,
    /// The creation timestamp of the last backup
    #[serde(rename = "backupCreatedAt", skip_serializing_if = "Option::is_none")]
    pub backup_created_at: Option<String>,
    /// Auto-stop interval in minutes (0 means disabled)
    #[serde(rename = "autoStopInterval", skip_serializing_if = "Option::is_none")]
    pub auto_stop_interval: Option<f64>,
    /// Auto-archive interval in minutes
    #[serde(rename = "autoArchiveInterval", skip_serializing_if = "Option::is_none")]
    pub auto_archive_interval: Option<f64>,
    /// Auto-delete interval in minutes (negative value means disabled, 0 means delete immediately upon stopping)
    #[serde(rename = "autoDeleteInterval", skip_serializing_if = "Option::is_none")]
    pub auto_delete_interval: Option<f64>,
    /// Array of volumes attached to the sandbox
    #[serde(rename = "volumes", skip_serializing_if = "Option::is_none")]
    pub volumes: Option<Vec<models::SandboxVolume>>,
    /// Build information for the sandbox
    #[serde(rename = "buildInfo", skip_serializing_if = "Option::is_none")]
    pub build_info: Option<Box<models::BuildInfo>>,
    /// The creation timestamp of the sandbox
    #[serde(rename = "createdAt", skip_serializing_if = "Option::is_none")]
    pub created_at: Option<String>,
    /// The last update timestamp of the sandbox
    #[serde(rename = "updatedAt", skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<String>,
    /// The class of the sandbox
    #[serde(rename = "class", skip_serializing_if = "Option::is_none")]
    pub class: Option<Class>,
    /// The version of the daemon running in the sandbox
    #[serde(rename = "daemonVersion", skip_serializing_if = "Option::is_none")]
    pub daemon_version: Option<String>,
    /// The runner ID of the sandbox
    #[serde(rename = "runnerId", skip_serializing_if = "Option::is_none")]
    pub runner_id: Option<String>,
    /// The image used for the workspace
    #[serde(rename = "image", skip_serializing_if = "Option::is_none")]
    pub image: Option<String>,
    /// The state of the snapshot
    #[serde(rename = "snapshotState", skip_serializing_if = "Option::is_none")]
    pub snapshot_state: Option<SnapshotState>,
    /// The creation timestamp of the last snapshot
    #[serde(rename = "snapshotCreatedAt", skip_serializing_if = "Option::is_none")]
    pub snapshot_created_at: Option<String>,
    /// Additional information about the sandbox
    #[serde(rename = "info", skip_serializing_if = "Option::is_none")]
    pub info: Option<Box<models::SandboxInfo>>,
}

impl Workspace {
    pub fn new(id: String, organization_id: String, name: String, user: String, env: std::collections::HashMap<String, String>, labels: std::collections::HashMap<String, String>, public: bool, network_block_all: bool, target: String, cpu: f64, gpu: f64, memory: f64, disk: f64) -> Workspace {
        Workspace {
            id,
            organization_id,
            name,
            snapshot: None,
            user,
            env,
            labels,
            public,
            network_block_all,
            network_allow_list: None,
            target,
            cpu,
            gpu,
            memory,
            disk,
            state: None,
            desired_state: None,
            error_reason: None,
            recoverable: None,
            backup_state: None,
            backup_created_at: None,
            auto_stop_interval: None,
            auto_archive_interval: None,
            auto_delete_interval: None,
            volumes: None,
            build_info: None,
            created_at: None,
            updated_at: None,
            class: None,
            daemon_version: None,
            runner_id: None,
            image: None,
            snapshot_state: None,
            snapshot_created_at: None,
            info: None,
        }
    }
}
/// The state of the backup
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum BackupState {
    #[serde(rename = "None")]
    None,
    #[serde(rename = "Pending")]
    Pending,
    #[serde(rename = "InProgress")]
    InProgress,
    #[serde(rename = "Completed")]
    Completed,
    #[serde(rename = "Error")]
    Error,
}

impl Default for BackupState {
    fn default() -> BackupState {
        Self::None
    }
}
/// The class of the sandbox
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum Class {
    #[serde(rename = "small")]
    Small,
    #[serde(rename = "medium")]
    Medium,
    #[serde(rename = "large")]
    Large,
}

impl Default for Class {
    fn default() -> Class {
        Self::Small
    }
}
/// The state of the snapshot
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum SnapshotState {
    #[serde(rename = "None")]
    None,
    #[serde(rename = "Pending")]
    Pending,
    #[serde(rename = "InProgress")]
    InProgress,
    #[serde(rename = "Completed")]
    Completed,
    #[serde(rename = "Error")]
    Error,
}

impl Default for SnapshotState {
    fn default() -> SnapshotState {
        Self::None
    }
}

