/*
 * Daytona Toolbox API
 *
 * Daytona Toolbox API
 *
 * The version of the OpenAPI document: v0.0.0-dev
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`click`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClickError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRecordingError {
    Status400(std::collections::HashMap<String, String>),
    Status404(std::collections::HashMap<String, String>),
    Status500(std::collections::HashMap<String, String>),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`download_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DownloadRecordingError {
    Status404(std::collections::HashMap<String, String>),
    Status500(std::collections::HashMap<String, String>),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`drag`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DragError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_computer_use_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetComputerUseStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_computer_use_system_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetComputerUseSystemStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_display_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDisplayInfoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_mouse_position`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMousePositionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_process_errors`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetProcessErrorsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_process_logs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetProcessLogsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_process_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetProcessStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRecordingError {
    Status404(std::collections::HashMap<String, String>),
    Status500(std::collections::HashMap<String, String>),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_windows`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWindowsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_recordings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRecordingsError {
    Status500(std::collections::HashMap<String, String>),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`move_mouse`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MoveMouseError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`press_hotkey`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PressHotkeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`press_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PressKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`restart_process`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestartProcessError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`scroll`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScrollError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_computer_use`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartComputerUseError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartRecordingError {
    Status400(std::collections::HashMap<String, String>),
    Status500(std::collections::HashMap<String, String>),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stop_computer_use`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StopComputerUseError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stop_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StopRecordingError {
    Status400(std::collections::HashMap<String, String>),
    Status404(std::collections::HashMap<String, String>),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`take_compressed_region_screenshot`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TakeCompressedRegionScreenshotError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`take_compressed_screenshot`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TakeCompressedScreenshotError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`take_region_screenshot`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TakeRegionScreenshotError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`take_screenshot`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TakeScreenshotError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`type_text`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TypeTextError {
    UnknownValue(serde_json::Value),
}


/// Click the mouse button at the specified coordinates
pub async fn click(configuration: &configuration::Configuration, request: models::MouseClickRequest) -> Result<models::MouseClickResponse, Error<ClickError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_request = request;

    let uri_str = format!("{}/computeruse/mouse/click", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MouseClickResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MouseClickResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ClickError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a recording file by ID
pub async fn delete_recording(configuration: &configuration::Configuration, id: &str) -> Result<(), Error<DeleteRecordingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!("{}/computeruse/recordings/{id}", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteRecordingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Download a recording by providing its ID
pub async fn download_recording(configuration: &configuration::Configuration, id: &str) -> Result<reqwest::Response, Error<DownloadRecordingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!("{}/computeruse/recordings/{id}/download", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<DownloadRecordingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Drag the mouse from start to end coordinates
pub async fn drag(configuration: &configuration::Configuration, request: models::MouseDragRequest) -> Result<models::MouseDragResponse, Error<DragError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_request = request;

    let uri_str = format!("{}/computeruse/mouse/drag", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MouseDragResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MouseDragResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DragError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the status of all computer use processes
pub async fn get_computer_use_status(configuration: &configuration::Configuration, ) -> Result<models::ComputerUseStatusResponse, Error<GetComputerUseStatusError>> {

    let uri_str = format!("{}/computeruse/process-status", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ComputerUseStatusResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ComputerUseStatusResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetComputerUseStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the current status of the computer use system
pub async fn get_computer_use_system_status(configuration: &configuration::Configuration, ) -> Result<models::ComputerUseStatusResponse, Error<GetComputerUseSystemStatusError>> {

    let uri_str = format!("{}/computeruse/status", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ComputerUseStatusResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ComputerUseStatusResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetComputerUseSystemStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get information about all available displays
pub async fn get_display_info(configuration: &configuration::Configuration, ) -> Result<models::DisplayInfoResponse, Error<GetDisplayInfoError>> {

    let uri_str = format!("{}/computeruse/display/info", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DisplayInfoResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DisplayInfoResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDisplayInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the current mouse cursor position
pub async fn get_mouse_position(configuration: &configuration::Configuration, ) -> Result<models::MousePositionResponse, Error<GetMousePositionError>> {

    let uri_str = format!("{}/computeruse/mouse/position", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MousePositionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MousePositionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMousePositionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get errors for a specific computer use process
pub async fn get_process_errors(configuration: &configuration::Configuration, process_name: &str) -> Result<models::ProcessErrorsResponse, Error<GetProcessErrorsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_process_name = process_name;

    let uri_str = format!("{}/computeruse/process/{processName}/errors", configuration.base_path, processName=crate::apis::urlencode(p_process_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProcessErrorsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProcessErrorsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetProcessErrorsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get logs for a specific computer use process
pub async fn get_process_logs(configuration: &configuration::Configuration, process_name: &str) -> Result<models::ProcessLogsResponse, Error<GetProcessLogsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_process_name = process_name;

    let uri_str = format!("{}/computeruse/process/{processName}/logs", configuration.base_path, processName=crate::apis::urlencode(p_process_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProcessLogsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProcessLogsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetProcessLogsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Check if a specific computer use process is running
pub async fn get_process_status(configuration: &configuration::Configuration, process_name: &str) -> Result<models::ProcessStatusResponse, Error<GetProcessStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_process_name = process_name;

    let uri_str = format!("{}/computeruse/process/{processName}/status", configuration.base_path, processName=crate::apis::urlencode(p_process_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProcessStatusResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProcessStatusResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetProcessStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get details of a specific recording by ID
pub async fn get_recording(configuration: &configuration::Configuration, id: &str) -> Result<models::Recording, Error<GetRecordingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;

    let uri_str = format!("{}/computeruse/recordings/{id}", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Recording`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Recording`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRecordingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get information about all open windows
pub async fn get_windows(configuration: &configuration::Configuration, ) -> Result<models::WindowsResponse, Error<GetWindowsError>> {

    let uri_str = format!("{}/computeruse/display/windows", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WindowsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WindowsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWindowsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of all recordings (active and completed)
pub async fn list_recordings(configuration: &configuration::Configuration, ) -> Result<models::ListRecordingsResponse, Error<ListRecordingsError>> {

    let uri_str = format!("{}/computeruse/recordings", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListRecordingsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListRecordingsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListRecordingsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Move the mouse cursor to the specified coordinates
pub async fn move_mouse(configuration: &configuration::Configuration, request: models::MouseMoveRequest) -> Result<models::MousePositionResponse, Error<MoveMouseError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_request = request;

    let uri_str = format!("{}/computeruse/mouse/move", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MousePositionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MousePositionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MoveMouseError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Press a hotkey combination (e.g., ctrl+c, cmd+v)
pub async fn press_hotkey(configuration: &configuration::Configuration, request: models::KeyboardHotkeyRequest) -> Result<serde_json::Value, Error<PressHotkeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_request = request;

    let uri_str = format!("{}/computeruse/keyboard/hotkey", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PressHotkeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Press a key with optional modifiers
pub async fn press_key(configuration: &configuration::Configuration, request: models::KeyboardPressRequest) -> Result<serde_json::Value, Error<PressKeyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_request = request;

    let uri_str = format!("{}/computeruse/keyboard/key", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PressKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Restart a specific computer use process
pub async fn restart_process(configuration: &configuration::Configuration, process_name: &str) -> Result<models::ProcessRestartResponse, Error<RestartProcessError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_process_name = process_name;

    let uri_str = format!("{}/computeruse/process/{processName}/restart", configuration.base_path, processName=crate::apis::urlencode(p_process_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProcessRestartResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProcessRestartResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RestartProcessError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Scroll the mouse wheel at the specified coordinates
pub async fn scroll(configuration: &configuration::Configuration, request: models::MouseScrollRequest) -> Result<models::ScrollResponse, Error<ScrollError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_request = request;

    let uri_str = format!("{}/computeruse/mouse/scroll", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScrollResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScrollResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ScrollError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Start all computer use processes and return their status
pub async fn start_computer_use(configuration: &configuration::Configuration, ) -> Result<models::ComputerUseStartResponse, Error<StartComputerUseError>> {

    let uri_str = format!("{}/computeruse/start", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ComputerUseStartResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ComputerUseStartResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StartComputerUseError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Start a new screen recording session
pub async fn start_recording(configuration: &configuration::Configuration, request: Option<models::StartRecordingRequest>) -> Result<models::Recording, Error<StartRecordingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_request = request;

    let uri_str = format!("{}/computeruse/recordings/start", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Recording`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Recording`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StartRecordingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Stop all computer use processes and return their status
pub async fn stop_computer_use(configuration: &configuration::Configuration, ) -> Result<models::ComputerUseStopResponse, Error<StopComputerUseError>> {

    let uri_str = format!("{}/computeruse/stop", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ComputerUseStopResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ComputerUseStopResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StopComputerUseError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Stop an active screen recording session
pub async fn stop_recording(configuration: &configuration::Configuration, request: models::StopRecordingRequest) -> Result<models::Recording, Error<StopRecordingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_request = request;

    let uri_str = format!("{}/computeruse/recordings/stop", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Recording`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Recording`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StopRecordingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Take a compressed screenshot of a specific region of the screen
pub async fn take_compressed_region_screenshot(configuration: &configuration::Configuration, x: i32, y: i32, width: i32, height: i32, show_cursor: Option<bool>, format: Option<&str>, quality: Option<i32>, scale: Option<f64>) -> Result<models::ScreenshotResponse, Error<TakeCompressedRegionScreenshotError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x = x;
    let p_y = y;
    let p_width = width;
    let p_height = height;
    let p_show_cursor = show_cursor;
    let p_format = format;
    let p_quality = quality;
    let p_scale = scale;

    let uri_str = format!("{}/computeruse/screenshot/region/compressed", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("x", &p_x.to_string())]);
    req_builder = req_builder.query(&[("y", &p_y.to_string())]);
    req_builder = req_builder.query(&[("width", &p_width.to_string())]);
    req_builder = req_builder.query(&[("height", &p_height.to_string())]);
    if let Some(ref param_value) = p_show_cursor {
        req_builder = req_builder.query(&[("showCursor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_quality {
        req_builder = req_builder.query(&[("quality", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_scale {
        req_builder = req_builder.query(&[("scale", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScreenshotResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScreenshotResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TakeCompressedRegionScreenshotError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Take a compressed screenshot of the entire screen
pub async fn take_compressed_screenshot(configuration: &configuration::Configuration, show_cursor: Option<bool>, format: Option<&str>, quality: Option<i32>, scale: Option<f64>) -> Result<models::ScreenshotResponse, Error<TakeCompressedScreenshotError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_show_cursor = show_cursor;
    let p_format = format;
    let p_quality = quality;
    let p_scale = scale;

    let uri_str = format!("{}/computeruse/screenshot/compressed", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_show_cursor {
        req_builder = req_builder.query(&[("showCursor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_quality {
        req_builder = req_builder.query(&[("quality", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_scale {
        req_builder = req_builder.query(&[("scale", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScreenshotResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScreenshotResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TakeCompressedScreenshotError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Take a screenshot of a specific region of the screen
pub async fn take_region_screenshot(configuration: &configuration::Configuration, x: i32, y: i32, width: i32, height: i32, show_cursor: Option<bool>) -> Result<models::ScreenshotResponse, Error<TakeRegionScreenshotError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x = x;
    let p_y = y;
    let p_width = width;
    let p_height = height;
    let p_show_cursor = show_cursor;

    let uri_str = format!("{}/computeruse/screenshot/region", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("x", &p_x.to_string())]);
    req_builder = req_builder.query(&[("y", &p_y.to_string())]);
    req_builder = req_builder.query(&[("width", &p_width.to_string())]);
    req_builder = req_builder.query(&[("height", &p_height.to_string())]);
    if let Some(ref param_value) = p_show_cursor {
        req_builder = req_builder.query(&[("showCursor", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScreenshotResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScreenshotResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TakeRegionScreenshotError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Take a screenshot of the entire screen
pub async fn take_screenshot(configuration: &configuration::Configuration, show_cursor: Option<bool>) -> Result<models::ScreenshotResponse, Error<TakeScreenshotError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_show_cursor = show_cursor;

    let uri_str = format!("{}/computeruse/screenshot", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_show_cursor {
        req_builder = req_builder.query(&[("showCursor", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScreenshotResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScreenshotResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TakeScreenshotError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Type text with optional delay between keystrokes
pub async fn type_text(configuration: &configuration::Configuration, request: models::KeyboardTypeRequest) -> Result<serde_json::Value, Error<TypeTextError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_request = request;

    let uri_str = format!("{}/computeruse/keyboard/type", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TypeTextError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

