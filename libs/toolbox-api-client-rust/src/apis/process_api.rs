/*
 * Daytona Toolbox API
 *
 * Daytona Toolbox API
 *
 * The version of the OpenAPI document: v0.0.0-dev
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`connect_pty_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConnectPtySessionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_pty_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreatePtySessionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSessionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_pty_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeletePtySessionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSessionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`execute_command`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExecuteCommandError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_pty_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPtySessionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSessionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_session_command`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSessionCommandError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_session_command_logs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSessionCommandLogsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_pty_sessions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListPtySessionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_sessions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSessionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`resize_pty_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResizePtySessionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`send_input`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SendInputError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_execute_command`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionExecuteCommandError {
    UnknownValue(serde_json::Value),
}


/// Establish a WebSocket connection to interact with a pseudo-terminal session
pub async fn connect_pty_session(configuration: &configuration::Configuration, session_id: &str) -> Result<(), Error<ConnectPtySessionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_session_id = session_id;

    let uri_str = format!("{}/process/pty/{sessionId}/connect", configuration.base_path, sessionId=crate::apis::urlencode(p_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ConnectPtySessionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new pseudo-terminal session with specified configuration
pub async fn create_pty_session(configuration: &configuration::Configuration, request: models::PtyCreateRequest) -> Result<models::PtyCreateResponse, Error<CreatePtySessionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_request = request;

    let uri_str = format!("{}/process/pty", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PtyCreateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PtyCreateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreatePtySessionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new shell session for command execution
pub async fn create_session(configuration: &configuration::Configuration, request: models::CreateSessionRequest) -> Result<(), Error<CreateSessionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_request = request;

    let uri_str = format!("{}/process/session", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSessionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a pseudo-terminal session and terminate its process
pub async fn delete_pty_session(configuration: &configuration::Configuration, session_id: &str) -> Result<std::collections::HashMap<String, serde_json::Value>, Error<DeletePtySessionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_session_id = session_id;

    let uri_str = format!("{}/process/pty/{sessionId}", configuration.base_path, sessionId=crate::apis::urlencode(p_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `std::collections::HashMap&lt;String, serde_json::Value&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `std::collections::HashMap&lt;String, serde_json::Value&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeletePtySessionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete an existing shell session
pub async fn delete_session(configuration: &configuration::Configuration, session_id: &str) -> Result<(), Error<DeleteSessionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_session_id = session_id;

    let uri_str = format!("{}/process/session/{sessionId}", configuration.base_path, sessionId=crate::apis::urlencode(p_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteSessionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Execute a shell command and return the output and exit code
pub async fn execute_command(configuration: &configuration::Configuration, request: models::ExecuteRequest) -> Result<models::ExecuteResponse, Error<ExecuteCommandError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_request = request;

    let uri_str = format!("{}/process/execute", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ExecuteResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ExecuteResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ExecuteCommandError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get detailed information about a specific pseudo-terminal session
pub async fn get_pty_session(configuration: &configuration::Configuration, session_id: &str) -> Result<models::PtySessionInfo, Error<GetPtySessionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_session_id = session_id;

    let uri_str = format!("{}/process/pty/{sessionId}", configuration.base_path, sessionId=crate::apis::urlencode(p_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PtySessionInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PtySessionInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPtySessionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get details of a specific session including its commands
pub async fn get_session(configuration: &configuration::Configuration, session_id: &str) -> Result<models::Session, Error<GetSessionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_session_id = session_id;

    let uri_str = format!("{}/process/session/{sessionId}", configuration.base_path, sessionId=crate::apis::urlencode(p_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Session`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Session`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSessionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get details of a specific command within a session
pub async fn get_session_command(configuration: &configuration::Configuration, session_id: &str, command_id: &str) -> Result<models::Command, Error<GetSessionCommandError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_session_id = session_id;
    let p_command_id = command_id;

    let uri_str = format!("{}/process/session/{sessionId}/command/{commandId}", configuration.base_path, sessionId=crate::apis::urlencode(p_session_id), commandId=crate::apis::urlencode(p_command_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Command`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Command`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSessionCommandError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get logs for a specific command within a session. Supports both HTTP and WebSocket streaming.
pub async fn get_session_command_logs(configuration: &configuration::Configuration, session_id: &str, command_id: &str, follow: Option<bool>) -> Result<String, Error<GetSessionCommandLogsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_session_id = session_id;
    let p_command_id = command_id;
    let p_follow = follow;

    let uri_str = format!("{}/process/session/{sessionId}/command/{commandId}/logs", configuration.base_path, sessionId=crate::apis::urlencode(p_session_id), commandId=crate::apis::urlencode(p_command_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_follow {
        req_builder = req_builder.query(&[("follow", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Ok(content),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSessionCommandLogsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of all active pseudo-terminal sessions
pub async fn list_pty_sessions(configuration: &configuration::Configuration, ) -> Result<models::PtyListResponse, Error<ListPtySessionsError>> {

    let uri_str = format!("{}/process/pty", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PtyListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PtyListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListPtySessionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of all active shell sessions
pub async fn list_sessions(configuration: &configuration::Configuration, ) -> Result<Vec<models::Session>, Error<ListSessionsError>> {

    let uri_str = format!("{}/process/session", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Session&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Session&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListSessionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Resize the terminal dimensions of a pseudo-terminal session
pub async fn resize_pty_session(configuration: &configuration::Configuration, session_id: &str, request: models::PtyResizeRequest) -> Result<models::PtySessionInfo, Error<ResizePtySessionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_session_id = session_id;
    let p_request = request;

    let uri_str = format!("{}/process/pty/{sessionId}/resize", configuration.base_path, sessionId=crate::apis::urlencode(p_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PtySessionInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PtySessionInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ResizePtySessionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send input data to a running command in a session for interactive execution
pub async fn send_input(configuration: &configuration::Configuration, session_id: &str, command_id: &str, request: models::SessionSendInputRequest) -> Result<(), Error<SendInputError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_session_id = session_id;
    let p_command_id = command_id;
    let p_request = request;

    let uri_str = format!("{}/process/session/{sessionId}/command/{commandId}/input", configuration.base_path, sessionId=crate::apis::urlencode(p_session_id), commandId=crate::apis::urlencode(p_command_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SendInputError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Execute a command within an existing shell session
pub async fn session_execute_command(configuration: &configuration::Configuration, session_id: &str, request: models::SessionExecuteRequest) -> Result<models::SessionExecuteResponse, Error<SessionExecuteCommandError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_session_id = session_id;
    let p_request = request;

    let uri_str = format!("{}/process/session/{sessionId}/exec", configuration.base_path, sessionId=crate::apis::urlencode(p_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SessionExecuteResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SessionExecuteResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionExecuteCommandError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

